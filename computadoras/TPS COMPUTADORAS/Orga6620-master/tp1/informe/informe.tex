\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage[top=2cm, bottom=1.5cm, left=2.5cm, right=1cm]{geometry}
\usepackage{listings}
\usepackage{mips}
\usepackage{verbatim}
\usepackage{pdfpages}
\usepackage{indentfirst}

\title{		\textbf{Versión en C del comando rev, con lógica en assembly}}

\author{	Lucas Simonelli, \textit{Padrón Nro. 93111}                     \\
            \texttt{ lucasp.simonelli@gmail.com }                                              \\[2.5ex]
            Tomás Boccardo, \textit{Padrón Nro. 93637}                     \\
            \texttt{ tomasboccardo@gmail.com}                                              \\[2.5ex]
            Andrés Sanabria, \textit{Padrón Nro. 93403}                     \\
            \texttt{ andresg.sanabria@gmail.com  }                                              \\[2.5ex]
            \normalsize{2do. Cuatrimestre de 2013}                                      \\
            \normalsize{66.20 Organización de Computadoras  $-$ Práctica Martes}  \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}
\begin{document}





\maketitle
\thispagestyle{empty}   % quita el número en la primer página


\begin{abstract}
El presente trabajo consiste en la implementación de un programa, similar al comando rev de Unix, encargado de concatenar y escribir en stdout el contenido invertido de cada línea, de uno o más archivos pasados como parámetros.
El manejo de parámetros se realizará en C, mientras que se implementará en assembly MIPS la función reverse(fd1, fd2), que dados dos fd, realiza la inversión del primero línea a línea y lo imprime al segundo.
\end{abstract}

\newpage
\section{Introducción}

El objetivo del trabajo desarrollado en este informe es familiarizarse con el conjunto de instrucciones MIPS y el concepto de ABI,
realizando en assembly MIPS una función que invierta línea a línea un archivo.

\section{Función}
El ejecutable tendrá el mismo objeto que el comando rev, es decir, leerá un archivo por alguno de los canales ofrecidos y lo invertirá línea a línea.

\section{Desarrollo}

\subsection{Diseño e Implementación}

Algunas suposiciones realizadas y detalles de implementación fueron los siguientes:
\begin{itemize} 
 \item Cada caracter mide 1 byte. 
 \item El programa recibe como parámetros los archivos sobre los que trabajar. En caso de no recibir ningún parámetro, opera sobre los datos provenientes de stdin.
 \item Dividimos nuestro programa en 3 módulos básicos, cada uno de los cuales tiene una tarea específica.
 \subitem \textbf{leerLinea (ASM)}: Se encarga, como su nombre lo indica, de leer caracter por caracter el contenido de una línea hasta encontrar el fin de archivo o el caracter de fin de línea. Recibe como parámetro el descriptor del archivo del que debe leer o el descriptor de stdin si este fuera el caso. Además recibe un puntero a un int donde almacenará el tamaño de la línea leida y un puntero a char pointer para almacenar los caracteres leidos. Devuelve 0 si la lectura fue exitosa o un número mayor a 0 si hubo un error.
 \subitem \textbf{invertirLinea (ASM)}: Este módulo se utiliza para invertir el orden de aparición de los caracteres en una línea. De este modo, el último caracter de la línea quedará en primer lugar y el primero último, y de forma análoga se intercambiaran el resto de los caracteres. Recibe como parámetro un buffer con la línea en su estado original y devuelve en ese mismo buffer, la línea invertida.
 \subitem \textbf{main (C)}: Por último, tenemos la función principal que se encarga de interpretar los parámetros con los que fue llamado el programa y llamar a los módulos antes mencionados cuando sea necesario. De acuerdo a los parámetros que le sean ingresados el programa se comportará de distinta manera: 
 \subsubitem Si recibe como párametro '-h' muestra por pantalla una breve explicación del uso del programa.
 \subsubitem En caso de recibir el parámetro '-V' muestra la versión del programa en ejecución.
 \subsubitem De no recibir parámetros lee por entrada standard e invierte el contenido de cada línea.
 \subsubitem En otro caso, abre e invierte las líneas de los archivos pasados como parámetro. En caso de fallar alguno de ellos, informa por stdout el nombre del archivo que no encontró.
Retorna 0 si la ejecución fue exitosa o un número mayor a 0 en otro caso.
\end{itemize}

\section{Comandos para la compilacion}
Para compilar el programa, deberá introducirse el siguiente comando:
\begin{verbatim}
#compilamos
~$./compile.sh

#corremos
~$./tp1 [archivo] [opciones]
\end{verbatim}

\subsection{Sintaxis de uso}
\begin{verbatim}
$ ./tp1 -h
Usage:
./tp1 -h
./tp1 -V
./tp1 [file...]
Options:
-V, --version, print version and quit.
-h, --help, print this information and quit.

Examples:
./tp1 foo.txt bar.txt
./tp1 gz.txt
echo "Hola mundo" | ./tp1
\end{verbatim}

\section{Corridas de prueba}
(Los archivos se facilitan junto con este informe en la entrega digital)
\subsection{Corrida con archivo de parámetro}
\begin{verbatim}
~$./tp1 ejemplo.txt
1elif ed aenil aremirp al se atsE
.adnuges al se atse y

\end{verbatim}
\subsection{Corrida con entrada de stdin}
\begin{verbatim}
~$echo "Hola mundo" | ./tp1
odnum aloH
\end{verbatim}

\section{Código fuente}
\subsection{main.c}
\lstinputlisting[language=C,breaklines=true]{../main.c}

\subsection{reverse.S}
\lstset{language=[mips]Assembler,breaklines=true}
\lstinputlisting{../reverse.S}

\section{Conclusiones}
\begin{itemize}
\item Se utilizó la ABI y se aprendieron las convenciones.
\item Se aprendió a compilar un programa en assembly y a linkearlo con código C.
\item Uno de los puntos más importantes es la cantidad de líneas de código que se escribieron en las funciones de assembly comparadas con las de 
C (mucho mayor). 
\subsection{Comparación tp1 vs tp0}

Se realizaron benchmarks sobre distintos archivos con ambos trabajos prácticos, a fin de determinar cual fue más rápido:

\begin{itemize}
\item \textbf{tp0:} sys time:  0m0.055s
\item \textbf{tp1:} sys time:  0m0.492s
\end{itemize}

(Archivo de prueba utilizado: reverse.S [el código fuente]).

Ante tanta diferencia se sospechó que el bottleneck podría estar en mymalloc, con lo que se diseño un benchmark para 
confirmarlo (sys\textunderscore mmap/malloc\textunderscore benchmark.c). El benchmark consiste en 1000 mallocs de 40 (tamaño inicial utilizado al leer las líneas) + 1000 reallocs de 80 (doble del tamaño inicial) + 1000 frees. Los resultados fueron los siguientes:

\begin{itemize}
\item \textbf{mymalloc:} sys time:  0m0.879s
\item \textbf{malloc:} sys time:  0m0.290s
\end{itemize}

Esta prueba permitió determinar que mymalloc es mucho más lento que el malloc de stdlib.h. Por lo tanto, 
se supone que esta es la causa de que el tp0 sea el mucho más rápido que el tp1.

Otra causa de la demora del tp1 podría deberse a que en el tp0 se escala el buffer de lectura en forma exponencial, en tanto que en 
el tp1 debido a la dificultad de hacer esto en assembly se optó por hacerlo en forma constante, menos óptima.

\end{itemize}
\section{Enunciado}
\includepdf[scale=0.8,pages={1,2,3,4}]{../enunciado.pdf}

\begin{comment}
\begin{thebibliography}{99}

\bibitem{INT06} Intel Technology \& Research, ``Hyper-Threading Technology,'' 2006, http://www.intel.com/technology/hyperthread/.

\bibitem{HEN00} J. L. Hennessy and D. A. Patterson, ``Computer Architecture. A Quantitative
Approach,'' 3ra Edición, Morgan Kaufmann Publishers, 2000.

\bibitem{LAR92} J. Larus and T. Ball, ``Rewriting Executable Files to Mesure Program Behavior,'' Tech. Report 1083, Univ. of Wisconsin, 1992.

\end{thebibliography}
\end{comment}
\end{document}
